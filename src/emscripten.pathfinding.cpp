// This file is used by jquery.wayfinding.js plugin to run Dijkstra's between to SVG rooms.
// It is compiled to JavaScript using the Emscripten compiler
// The binding of the C++ functions to JavaScript is done using Emscripten's Embind feature
// RapidJSON is used to parse the stringified JSON passed when called by JavaScript code.

#include <string>
#include <set>
#include <vector>
#include <map>
#include <climits>

#include <emscripten/bind.h>
#include "rapidjson/document.h"

using namespace rapidjson;
using namespace std;

// There are three types of nodes in our datastore.
// The stop type is used to indicated the end of the path generated by Dijkstra's
enum nodeType {path, door, portal, stop};
string stringTypes[] = {"path", "door", "portal", "stop"};

// generic graph node
class Node
{
  public:
    int id;

    // Adjacent paths, portals, and doors
    // Stored by ID
    vector<int> paths;
    vector<int> portals;
    vector<int> doors;

    int floor;

    nodeType type;

    float weight;

    // Path stuff
    int pathID;

    // Door stuff
    // The door's name. typically looks like "R123"
    string doorID;
    // These bools are used to indicate if the node is the starting or ending node for Dijkstras
    bool start;
    bool end;

    // Portal stuff
    string portalID;
    // Portals pair with other portals located on different floors
    // toFloor indicates what floor at portal's pair is on
    // matchID is the ID of the portal's pair
    // both are -1 if a portal does not have a pair
    int toFloor;
    int matchID;
    // Usually, there are two types of portals: stairs or elevators
    // This is to indicate if a portal is wheelchair accessible (elevators) for the Dijkstras code
    bool accessible;

    // Orders nodes by ID, floor, and type, in that order.
    // Need to use priority queue for pathfinding
    bool operator<(const Node other) const
    {
      if (id == other.id) {
        if (floor == other.floor) {
          return type < other.type;
        }
        else {
          return floor < other.floor;
        }
      }
      else {
        return id < other.id;
      }
    }

};

class Graph
{
  public:

    // number of floors in the graph
    int floors;

    // This is set to true in Dijkstra's if a path is found between the start and end
    // This is used to indicated if a no path found error has occurred
    bool foundPath = false;

    vector< vector<Node> > paths;
    vector< vector<Node> > doors;
    vector< vector<Node> > portals;

    // Finds the shortest path from (startFloor, startID) to (endFloor, endID)
    // Returns a map containing the route in reverse.
    // Accessible indicates whether to find a wheelchair accesible path
    // Called only by the pathfinding function
    map<Node, Node> dijkstra(int startID, int startFloor, int endID,
        int endFloor, bool accessible)
    {
      Node start = doors[startFloor][startID];
      Node end = doors[endFloor][endID];

      map<Node, Node> path;
      map<Node, int> minDist;

      // Set all node distances to infinity
      for (int floor = 0; floor < floors; floor++)
      {
        for (auto node : doors[floor])
        {
          minDist[node] = INT_MAX;
        }

        for(auto node : paths[floor])
        {
          minDist[node] = INT_MAX;
        }

        for(auto node : portals[floor])
        {
          minDist[node] = INT_MAX;
        }
      }

      // Mark the start node
      minDist[start] = 0;
      path[start] = Node();
      path[start].type = stop;

      // Set up our priority queue
      set< pair<int, Node> > activeNodes;
      activeNodes.insert({0, start});

      while(!activeNodes.empty())
      {
        // extract the next node to be processed
        Node currentNode = activeNodes.begin()->second;
        if (currentNode.type == door) {
          // Stop if we've reached our destination
          if (currentNode.id == end.id && currentNode.floor == end.floor)
          {
            foundPath = true;
            return path;
          }
        }

        activeNodes.erase(activeNodes.begin());
        for (auto neighborID : currentNode.paths)
        {
          Node neighbor = paths[currentNode.floor][neighborID];
          if (minDist[neighbor] > minDist[currentNode] + neighbor.weight)
          {
            updateNeighborDistance(currentNode, neighbor, activeNodes, minDist);
            path[neighbor] = currentNode;
          }
        }
        for (auto neighborID : currentNode.doors)
        {
          Node neighbor = doors[currentNode.floor][neighborID];
          if (minDist[neighbor] > minDist[currentNode] + neighbor.weight)
          {
            updateNeighborDistance(currentNode, neighbor, activeNodes, minDist);
            path[neighbor] = currentNode;
          }
        }
        for (auto neighborID : currentNode.portals)
        {
          Node neighbor = portals[currentNode.floor][neighborID];
          // If we're looking for an accessible route and the current portal is not, skip it
          if (accessible && !neighbor.accessible)
          {
            continue;
          }

          if (minDist[neighbor] > minDist[currentNode] + neighbor.weight)
          {
            updateNeighborDistance(currentNode, neighbor, activeNodes, minDist);
            path[neighbor] = currentNode;
          }
        }
        // Need to add the portal's pair to the set of nodes to be visited
        if (currentNode.type == portal && currentNode.matchID != -1 && currentNode.toFloor != -1)
        {
          Node neighbor = portals[currentNode.toFloor][currentNode.matchID];
          if (minDist[neighbor] > minDist[currentNode] + neighbor.weight)
          {
            updateNeighborDistance(currentNode, neighbor, activeNodes, minDist);
            path[neighbor] = currentNode;
          }
        }
      }

      foundPath = false;
      // If the destination was never reached, return this empty route
      map<Node, Node> error{{Node(), Node()}};
      return error;
    }

    void updateNeighborDistance(Node currentNode, Node neighbor,
      set< pair<int, Node> >& activeNodes, map<Node, int>& minDist)
    {
      activeNodes.erase({minDist[neighbor], neighbor});
      minDist[neighbor] = minDist[currentNode] + neighbor.weight;
      activeNodes.insert({minDist[neighbor], neighbor});
    }
};

// This function is called by JavaScript code by writing Module.pathfinding()
// dataStore should be stringified JSON of the map datastore
// startString & endString are the room names of the start and end point
// accessible is to indicated whether the user wants a wheelchair accessible route
// Returns a vector<string> that is JavaScript is able to work with
vector<string> pathfinding(string dataStore, string startString,
    string endString, bool accessible)
{
  Graph graph;

  int startID = -1, endID = -1, startFloor = -1, endFloor = -1;

  // Read in JSON object
  const char* json = dataStore.c_str();

  // Parse JSON object
  Document document;
  document.Parse(json);

  // Get the number of floors
  graph.floors = document["doors"].Size();

  // Make the data vectors the right size
  graph.doors.resize(graph.floors);
  graph.paths.resize(graph.floors);
  graph.portals.resize(graph.floors);

  // Go through each floor in datastore and make the graph object
  for (int floor = 0; floor < graph.floors; floor++)
  {
    // Turn doors into nodes
    Value& doorElements = document["doors"][floor];

    for (int index = 0; index < doorElements.Size(); index++)
    {
      Node doorNode;
      doorNode.floor = floor;
      doorNode.type = door;
      doorNode.id = doorElements[index]["id"].GetInt();
      doorNode.doorID = doorElements[index]["doorId"].GetString();
      doorNode.weight = 0;

      // Check for start and end nodes
      if (doorNode.doorID == startString)
      {
        doorNode.start = true;
        startID = doorNode.id;
        startFloor = doorNode.floor;
      }
      else {
        doorNode.start = false;
      }

      if (doorNode.doorID == endString)
      {
        doorNode.end = true;
        endID = doorNode.id;
        endFloor = doorNode.floor;
      }
      else {
        doorNode.end = false;
      }

      for (int j = 0; j < doorElements[index]["doors"].Size(); j++)
      {
        doorNode.doors.push_back(doorElements[index]["doors"][j].GetInt());
      }

      for (int j = 0; j < doorElements[index]["paths"].Size(); j++)
      {
        doorNode.paths.push_back(doorElements[index]["paths"][j].GetInt());
      }

      for (int j = 0; j < doorElements[index]["portals"].Size(); j++)
      {
        doorNode.portals.push_back(
            doorElements[index]["portals"][j].GetInt());
      }

      graph.doors[floor].push_back(doorNode);
    } // end of doors

    // Turn paths into nodes
    Value& pathElements = document["paths"][floor];

    for (int index = 0; index < pathElements.Size(); index++)
    {
      Node pathNode;
      pathNode.floor = floor;
      pathNode.type = path;
      pathNode.id = pathElements[index]["id"].GetInt();
      pathNode.pathID = pathElements[index]["pathId"].GetInt();
      pathNode.weight = pathElements[index]["length"].GetDouble();

      for (int j = 0; j < pathElements[index]["doors"].Size(); j++)
      {
        pathNode.doors.push_back(pathElements[index]["doors"][j].GetInt());
      }

      for (int j = 0; j < pathElements[index]["paths"].Size(); j++)
      {
        pathNode.paths.push_back(pathElements[index]["paths"][j].GetInt());
      }

      for (int j = 0; j < pathElements[index]["portals"].Size(); j++)
      {
        pathNode.portals.push_back(
            pathElements[index]["portals"][j].GetInt());
      }

      graph.paths[floor].push_back(pathNode);
    } // end of paths

    // Turn portals into nodes
    Value& portalElements = document["portals"][floor];

    for (int index = 0; index < portalElements.Size(); index++)
    {
      Node portalNode;
      portalNode.floor = floor;
      portalNode.type = portal;
      portalNode.id = portalElements[index]["id"].GetInt();
      portalNode.portalID = portalElements[index]["portalId"].GetString();
      portalNode.weight = portalElements[index]["length"].GetDouble();
      portalNode.accessible = portalElements[index]["accessible"].GetBool();
      portalNode.toFloor = portalElements[index]["toFloor"].GetInt();
      portalNode.matchID = portalElements[index]["match"].GetInt();

      for (int j = 0; j < portalElements[index]["doors"].Size(); j++)
      {
        portalNode.doors.push_back(
            portalElements[index]["doors"][j].GetInt());
      }

      for (int j = 0; j < portalElements[index]["paths"].Size(); j++)
      {
        portalNode.paths.push_back(
            portalElements[index]["paths"][j].GetInt());
      }

      for (int j = 0; j < portalElements[index]["portals"].Size(); j++)
      {
        portalNode.portals.push_back(
            portalElements[index]["portals"][j].GetInt());
      }

      graph.portals[floor].push_back(portalNode);
    } // end of portals
  } // end of floors

  // Run dijkstra's
  // elements will hold the returned path from Dijkstra's
  // This will also hold an error if one occurs
  // Possible errors are invalid rooms or no path between rooms
  vector<string> elements;

  // Check if the start and/or end room were not found
  // If so, return an error
  if (startID == -1 && startFloor == -1 && endID == -1 && endFloor == -1)
  {
    string error;
    error = "Invalid rooms, start: " + startString + ", end: " + endString;
    elements.push_back(error);
  }
  else if (startID == -1 && startFloor == -1)
  {
    string error;
    error = "Invalid room, start: " + startString;
    elements.push_back(error);
  }
  else if (endID == -1 && endFloor == -1)
  {
    string error;
    error = "Invalid room, end: " + endString;
    elements.push_back(error);
  }
  else
  {
    graph.foundPath = false;

    map<Node, Node> route = graph.dijkstra(startID, startFloor, endID,
        endFloor, accessible);

    if (graph.foundPath)
    {
      string el;

      int pathCount = 0;
      Node target = graph.doors[endFloor][endID];

      // Add the nodes from the route to the element vector
      // Strings are pushed into
      // The strings have the format nodetype-nodefloor-nodeid. Ex: path-0-1
      while (route[target].type != stop)
      {
        el = stringTypes[target.type] + "-" + to_string(target.floor) + "-" +
          to_string(target.id);
        elements.push_back(el);
        target = route[target];
        pathCount++;
      }

      // Make sure to the get last node
      el = stringTypes[target.type] + "-" + to_string(target.floor) + "-" +
        to_string(target.id);
      elements.push_back(el);
    }
    else
    {
      // No route was found, so return error
      string error;
      error = "Path not found between start: " + startString + " & end: ";
      error += endString;
      elements.push_back(error);
    }
  }

  return elements;
}

// Emscripten bindings
// JavaScript needs to know how to handle a vector<string>
// pathfinding is the function we want JavaScript to call
EMSCRIPTEN_BINDINGS(my_module) {
  emscripten::register_vector<string>("VectorString");
  emscripten::function("pathfinding", &pathfinding);
}